#C:\Users\PROGRESA HUACHIPA\OneDrive\Escritorio\BISem12\BuenaAventura\LSTM.py
# -*- coding: utf-8 -*-
"""Eq.D_Buenaventura

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TwldTMHFwQpVQarDqC2pmdoZsCe54Vvr

# IMPORTING LIBRARIES
"""

# Basicos
import streamlit as st
import pandas as pd # Manipulación y análisis de datos
import numpy as np # Operaciones numéricas y algebra lineal

# Extraer información del instrumento financiero
import yfinance as yf # Descarga de datos financieros desde Yahoo Finance

# Preprocesamiento
from sklearn.model_selection import train_test_split # División de los datos en conjuntos de entrenamiento y prueba
from sklearn.preprocessing import StandardScaler # Escalado de características
from sklearn.preprocessing import MinMaxScaler # Escalado de características a un rango específico
from statsmodels.tsa.seasonal import seasonal_decompose # Descomposición de series temporales

# Evaluacion
from sklearn.metrics import mean_squared_error, mean_absolute_percentage_error # Métricas de evaluación

# Visualizaciones
import matplotlib.pyplot as plt # Generación de gráficos y visualizaciones
import seaborn as sns # Visualización de datos estadísticos

# RNN: LSTM
from tensorflow.keras.models import Sequential # Creación de modelos secuenciales de Keras
from tensorflow.keras.layers import LSTM, Dense # Capas LSTM y densas para redes neuronales

# Support Vector Regressor
from sklearn.model_selection import GridSearchCV # Búsqueda en cuadrícula para optimización de hiperparámetros
from sklearn.svm import SVR # Soporte vectorial para regresión
from sklearn.pipeline import Pipeline # Creación de pipelines para flujos de trabajo de ML

# ANN: MLP Regressor
from sklearn.neural_network import MLPRegressor # Regressor de perceptrón multicapa

# Modelo Híbrido
from sklearn.kernel_approximation import RBFSampler # Aproximación de kernel de base radial (RBF)
from sklearn.linear_model import Ridge # Regresión Ridge
from sklearn.pipeline import make_pipeline # Creación de pipelines para flujos de trabajo de ML

import plotly.graph_objects as go
import plotly.figure_factory as ff



def extraccion_datos(df, instrumento_financiero, fecha_inicio, fecha_fin):
    # Descargar datos históricos de Buenaventura en un rango de fechas específico
    bvn_df = yf.download(instrumento_financiero, start=fecha_inicio , end=fecha_fin)

    """## Análisis Exploratorio de datos (EDA)

    Información del dataframe
    """

    # Mostrar las primeras filas del DataFrame
    print(bvn_df.head())

    bvn_df.info()

    bvn_df.describe()

    # Calcular la media móvil exponencial
    bvn_df['EMA'] = bvn_df['Open'].ewm(span=20, adjust=False).mean()

    # Graficar la variación en el tiempo del precio de apertura y la media móvil exponencial
    fig1 = go.Figure()

# Añadir la traza del precio de apertura (Open)
    fig1.add_trace(go.Scatter(x=bvn_df.index, y=bvn_df['Open'], mode='lines', name='Open Price'))

    # Añadir la traza de la EMA (20 días)
    fig1.add_trace(go.Scatter(x=bvn_df.index, y=bvn_df['EMA'], mode='lines', name='EMA (20 días)', line=dict(color='red')))

    # Configurar el diseño de la figura
    fig1.update_layout(
        title='Variación en el tiempo del precio de apertura (Open) con EMA',
        xaxis_title='Fecha',
        yaxis_title='Precio de apertura',
        legend_title='Legend',
        template='plotly_white',
        xaxis=dict(rangeslider=dict(visible=True))  # Añadir un deslizador de rango en el eje x
    )
    """"""

    """Aumento y Caída (2018-2020): Vemos que desde 2018 hasta principios de 2020, hubo una tendencia general al alza en el precio de apertura, alcanzando un pico a principios de 2020.

    Caída Significativa (2020): A principios de 2020, hay una caída abrupta y significativa en el precio de apertura, lo cual podría estar relacionado con la crisis del COVID-19 que afectó a los mercados globales.

    Recuperación y Fluctuaciones (2020-2021): Tras la caída, el precio comenzó a recuperarse, mostrando varias fluctuaciones a lo largo del tiempo, pero sin alcanzar los niveles pre-crisis.
    """

    # Variacion del volumen (Volume) en el tiempo (escala = e8)
    sns.lineplot(data=bvn_df, x="Date", y="Volume")
    plt.title("Volume Over Time")
    plt.show()

    # Calcular los retornos diarios
    bvn_df['Returns'] = bvn_df['Close'].pct_change()

    # Graficar la distribución de los retornos
    # Crear la figura usando Plotly
    fig2 = ff.create_distplot(
        [bvn_df['Returns'].dropna()], 
        group_labels=['Returns'], 
        bin_size=0.01, 
        show_curve=True, 
        colors=['blue']
    )

    # Configurar el diseño de la figura
    fig2.update_layout(
        title='Distribución de Retornos Diarios',
        xaxis_title='Retornos',
        yaxis_title='Frecuencia',
        template='plotly_white'
    )

    """El pico más alto de la distribución está cerca de cero, indicando que la mayoría de los retornos diarios son pequeños (cercanos al 0%).
    Esto sugiere que en promedio, las variaciones diarias en el precio de la acción son pequeñas, con retornos diarios promedio cercanos a cero.
    """

    # Descomposición de la serie temporal
    decomposition = seasonal_decompose(bvn_df['Close'].dropna(), model='multiplicative', period=365)
    decomposition.plot()
    plt.show()

    """Serie Temporal Original (Close)
    Gráfico de la serie temporal original que muestra el precio de cierre diario a lo largo del tiempo.

    Componente de Tendencia (Trend)
    Gráfico de la tendencia que muestra la dirección general del precio de cierre, eliminando las fluctuaciones a corto plazo.

    Componente Estacional (Seasonal)
    Gráfico estacional que muestra los patrones que se repiten anualmente en la serie temporal.

    Componente de Residuos (Resid)
    Gráfico de residuos que muestra las variaciones no explicadas por la tendencia ni por los patrones estacionales.

    ##PREPROCESAMIENTO

    Como el dataframe no contiene nulos procedemos a la creación de nuevas variables
    """

    # Añadir nuevas columnas basadas en la descripción
    bvn_df['Precio Anterior'] = bvn_df['Close'].shift(1)
    bvn_df['Precio Máximo Anterior'] = bvn_df['High'].shift(1)
    bvn_df['Precio Mínimo Anterior'] = bvn_df['Low'].shift(1)
    bvn_df['Precio Apertura Anterior'] = bvn_df['Open'].shift(1)
    bvn_df['PM_10'] = bvn_df['Close'].rolling(window=10).mean()

    # Calcular bandas de Bollinger
    bvn_df['Middle Band Bollinger'] = bvn_df['Close'].rolling(window=20).mean()
    bvn_df['Upper Band Bollinger'] = bvn_df['Middle Band Bollinger'] + 1.96 * bvn_df['Close'].rolling(window=20).std()
    bvn_df['Lower Band Bollinger'] = bvn_df['Middle Band Bollinger'] - 1.96 * bvn_df['Close'].rolling(window=20).std()

    # Gráfico: Precio de Cierre con Bandas de Bollinger
    fig3 = go.Figure()

# Añadir la línea de Precio de Cierre
    fig3.add_trace(go.Scatter(
        x=bvn_df.index, 
        y=bvn_df['Close'], 
        mode='lines', 
        name='Precio de Cierre'
    ))

    # Añadir la línea de Banda Superior Bollinger
    fig3.add_trace(go.Scatter(
        x=bvn_df.index, 
        y=bvn_df['Upper Band Bollinger'], 
        mode='lines', 
        name='Banda Superior Bollinger',
        line=dict(color='green')
    ))

    # Añadir la línea de Banda Inferior Bollinger
    fig3.add_trace(go.Scatter(
        x=bvn_df.index, 
        y=bvn_df['Lower Band Bollinger'], 
        mode='lines', 
        name='Banda Inferior Bollinger',
        line=dict(color='red')
    ))

    # Añadir el relleno entre las bandas de Bollinger
    fig3.add_trace(go.Scatter(
        x=bvn_df.index.tolist() + bvn_df.index.tolist()[::-1],
        y=bvn_df['Upper Band Bollinger'].tolist() + bvn_df['Lower Band Bollinger'].tolist()[::-1],
        fill='toself',
        fillcolor='rgba(128, 128, 128, 0.2)',
        line=dict(color='rgba(255,255,255,0)'),
        showlegend=False
    ))

    # Configurar el diseño de la figura
    fig3.update_layout(
        title='Precio de Cierre con Bandas de Bollinger',
        xaxis_title='Fecha',
        yaxis_title='Precio',
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        template='plotly_white'
    )

    # Calcular precio medio
    bvn_df['Precio Medio'] = (bvn_df['High'] + bvn_df['Low'] + bvn_df['Close']) / 3

    # Precio de la plata
    silver_df = yf.download('SI=F', start='2018-01-01', end='2024-01-01')
    bvn_df['Precio Plata'] = silver_df['Close']

    # Gráfico: Comparación del Precio de Cierre con el Precio de la Plata(onza troy = 31,1 gramos)
    fig4 = go.Figure()

    # Añadir la línea de Precio de Cierre
    fig4.add_trace(go.Scatter(
        x=bvn_df.index, 
        y=bvn_df['Close'], 
        mode='lines', 
        name=f'Precio de Cierre {instrumento_financiero}'
    ))

    # Añadir la línea de Precio de la Plata
    fig4.add_trace(go.Scatter(
        x=bvn_df.index, 
        y=bvn_df['Precio Plata'], 
        mode='lines', 
        name='Precio de la Plata',
        line=dict(color='silver')
    ))

    # Configurar el diseño de la figura
    fig4.update_layout(
        title='Comparación del Precio de Cierre con el Precio de la Plata',
        xaxis_title='Fecha',
        yaxis_title='Precio',
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        template='plotly_white'
    )

    # Eliminar filas con valores NaN generados por los cálculos de rolling y shift
    bvn_df.dropna(inplace=True)

    # Mostrar las primeras filas del DataFrame para verificar las nuevas columnas
    print(bvn_df.head())

    return bvn_df, fig1, fig2, fig3, fig4
